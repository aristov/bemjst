BEMJST
------

Это lite-версия [XJST](https://github.com/veged/xjst), адаптированная и оптимизированная для написания шаблонов в [БЭМ-предметной области](http://ru.bem.info). BEMJST-шаблоны имеют JavaScript-совместимый синтаксис и не требуют компиляции.

[Демо](http://ein.vault22.ru/bemjst-demo/)

## Синтаксис.

### Оператор template.

```
BEMJST.template ~ _
```

```
_(предикат) (тело);
```

#### Предикат.

Может быть одиночным или набором подпредикатов через запятую:

```
_(подпредикат1, подпредикат2, ...) (тело);
```

Вместо тела можно писать вложенные шаблоны:

```
_(общий подпредикат) (
    _(подпредикат1) (тело1),
    _(подпредикат2) (тело2),
    ...
);
```

Такая запись эквивалентна следующей:

```
_(общий подпредикат, подпредикат1) (тело1);
_(общий подпредикат, подпредикат2) (тело2);
...
```

Количество вложенных шаблонов и уровень вложенности неограничены.

Подпредикаты могут быть следующих типов:

- Boolean (true или false);
- Object - объект, поля которого при подборе шаблона сравниваются с полями контекста;
- Function - позволяет делать произвольные вычисления, должна возвращать true или false;
- String - синтаксический сахар над подпредикатом типа Object - позволяет записывать условия в более лаконичном виде.

При инициализации все подпредикаты типа String преобразуются в Object по следующему принципу:

```javascript
'tag' => { _mode: 'tag' }
'elem item' => { elem: 'item' }
'mod size m' => { mod: { size: 'm' } }
'a b c d e f g h' => { a: { b: { c: { d: { e: { f: { g: 'h' } } } } } } }
```

Одной строкой можно описать сразу несколько подпредикатов (через запятую-пробел):

```javascript
'block menu, elem item, tag' ~ { block: 'menu', elem: 'item', _mode: 'tag' }
```

При таком подходе потребовалось ввести дополнительные хелперы для ситуаций, когда нужно сделать такие проверки как существование или отсутствие значения:

```javascript
this.elem
{ elem: isTrue } ~ 'elem *' ~ '*elem'
```

```javascript
!this.elem
{ elem: isFalse } ~ 'elem !' ~ '!elem'
```

```javascript
this.elem !== 'item'
{ elem: isNot('item') } ~ 'elem !item'
```

Кроме того для любого ключа контекста можно написать любую проверку передав в качестве значения функцию:

```javascript
{ ctx: { url: function(url) { return /yandex\.ru/.test(url) } }
```

Эта функции выполняется в BEM-контексте (this). Первым аргументом ей передается соответствующее значение ключа контекста (this.ctx.url).

В BEMJST нет необходимости проверять существование полей при глубоко вложенных проверках:

XJST:

```javascript
this.ctx.data.operator.role === 'superuser'
```

- при отсутствии объекта data или operator возникнет js-ошибка. Для корректной работы этот предикат придется дополнить следующим образом:

```javascript
(this.ctx.data && this.ctx.data.operator && this.ctx.data.operator.role === 'superuser')
```

BEMJST:

```javascript
{ ctx: { data: { operator: { role: 'superuser' } } } } ~ 'ctx data operator role superuser'
```

- ошибки не будет.

Подпредикат типа Function выполняется каждый раз при подборе шаблона, вызывается в BEM-контексте и в качестве первого аргумента получает текущий контекст (this.ctx):

```javascript
function(ctx) { return this._.isArray(ctx) }
```

#### Тело.

В качестве тела шаблона можно указать что угодно. Если в качестве тела передана функция, то при выборе соответствующего шаблона она выполняется и в качестве тела используется возвращаемое значение.

Если тело шаблона представляет собой BEMJSON (обычно это шаблоны по моде content), то его нужно обязательно заворачивать в функцию:

неправильно:

```javascript
_('block popup, content') ({ elem: 'body' });
```

правильно:

```javascript
_('block popup, content')
    (function() {
        return { elem: 'body' };
    });
```

Тело-функция выполняется в BEM-контексте (this), первым аргументом ей передается текущий контекст (this.ctx).

```javascript
_('block link, attrs')
    (function(ctx) {
        return { href: ctx.url };
    });
```

### Оператор local.

```javascript
BEMJST.local ~ local
```

Представляет собой функцию от двух аргументов: объект, задающий локальные модификации контекста this и callback-функция, выполняемая в модифицированном контексте (тело). После выполнения все изменения контекста откатываются:

```javascript
this.a; // => 42
local({ a: 666 }, function() {
    this.a; // => 666
});
this.a; // => 42
```

Оператор модифицирует значения полей только первого уровня:

```javascript
this.ctx // => { target: 'blank', url: 'google.com' }
local({ _mode: 'attrs', ctx: { url: 'ya.ru' } }, function() {
    this.ctx; // => { url: 'ya.ru' }
});
```

Как видно из примера, поле target будет недоступно, т.к. this.ctx будет указывать на другой объект. Если необходимо выполнить такое преобразование, его можно записать вручную:

```javascript
var url = this.ctx.url; // 'google.com' - запоминаем
this.ctx.url = 'ya.ru'; // модифицируем
local({ _mode: 'attrs' }, function() {
    this.ctx; // => { target: 'blank', url: 'ya.ru' }
});
this.ctx.url = url; // откатываем
```

На практике такая потребность возникает очень редко и этот подход не создает серьезных неудобств.

Вместо объекта модификаций может быть указана строка - мода:

```javascript
local('mix', function() { /*...*/ }) ~ local({ _mode: 'mix' }, function() { /*...*/ })
```

### Оператор apply.

```
apply(модифицирующий объект);
```

Функция от одного аргумента. Позволяет заново запустить процедуру подбора шаблона непостредственно из тела шаблона. Первым параметром можно указать объект модификаций контекста (аналогично local).

### Оператор applyNext.

```
applyNext(модифицирующий объект);
```

В отличии от текущей реализации XJST, где подбор шаблона начинается сначала, а шаблон, в теле которого произошел вызов applyNext, игнорируется, в BEMJST оператор запускает процедуру подбора начиная со следующего (расположенного выше) шаблона.

```javascript
_('block next')
    (function() {
        return 'next 1';
    });

_('block first')
    (function() {
        return applyNext({ block: 'next' });
    });

_('block next')
    (function() {
        return 'next 2';
    });

BEMJST.build({ block: 'first' }); // 'next 1'
```

Как видно из примера, шаблон, возвращающий строку 'next 2' будет недостижим. В XJST аналогичный код вернул бы результат 'next 2'.

### Оператор applyCtx.

```
applyCtx(новое значение ctx);
```

В отличии от XJST, оператор не имеет защиты от зацикливания.

```javascript
applyCtx({ block: 'table' }) ~ apply({ _mode: '', ctx: { block: 'table' } })
```

Для оборачивания контекста следует использовать моду wrap:

```javascript
_('elem input, wrap')
    (function(ctx) {
        return {
            elem: 'layout',
            content: ctx
        }
    });
```

## Этапы шаблонизации

- сбор шаблонов
- инициализация + разогрев
- построение БЭМ-дерева
- генерация HTML

## Использование

```javascript
BEMHTML.apply(BEMJST.build(bemjson));
```

Для генерации HTML из построенного в BEMJST БЭМ-дерева используются скомпилированные базовые шаблоны [BEMHTML](https://github.com/bem/bemhtml).
